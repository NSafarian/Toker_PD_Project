---
title: "Script 3_DE Analysis Using DESeq2 Package"
author: "Nickie Safarian"
date: "6/22/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script shows the standard workflow to detect differential expressed genes using DESeq2 package. 


## Load Packages
```{r, message=FALSE, include=FALSE}

library(DESeq2)
library(tidyverse)

```

## Input data
```{r}

dds.new <- readRDS(
  "/external/rprshnas01/kcni/nsafarian/Toker_PD_Project/pd_complex-i_stratification/Data/Nickie/DESeq2/dds.new.10to1Mcounts.MultiFactorial.Rds")

```

## Ensure proper reference levels for factors
```{r}

dds.new$Sex <- relevel(dds.new$Sex, "M")
dds.new$Cohort2 <- relevel(dds.new$Cohort2,"Barcelona")
dds.new$MT.Grouping <- relevel(dds.new$MT.Grouping,"NonMT_PD")

```

## Run the DESeq analysis
```{r}

dds.new <- DESeq(dds.new)

```

## get the coefficients names
```{r}

resultsNames(dds.new)

```

## Extract differential expression results
```{r}

# contrast between MT_PD and Non_MT_PD
Res.main <- results(dds.new, contrast=c("MT.Grouping", "MT_PD" , "NonMT_PD"))
Res.interact <- results(dds.new, contrast=list(c("SexF.MT.GroupingMT_PD", "MT.Grouping_MT_PD_vs_NonMT_PD")))

```

## View summary of results
```{r}

summary(Res.main)
```

```{r}

summary(Res.interact)
```

## How many adjusted p-values are less than 0.05?
```{r}

sum(Res.main$padj < 0.05, na.rm=TRUE)

```

```{r}

sum(Res.interact$padj < 0.05, na.rm=TRUE)

```

## Get the significant results file
### *First remove NAs from padj column*
```{r}

noNA.main <- Res.main[!is.na(Res.main$padj), ]
noNA.intr <- Res.interact[!is.na(Res.interact$padj), ]

```

### *Then, set the padj cutoff at 0.05*
```{r}

sigs.main <- noNA.main[noNA.main$padj < 0.05, ]
sigs.intr <- noNA.intr[noNA.intr$padj < 0.05, ]

```

### *Review the results*
```{r}
summary(sigs.main)
```

```{r}
summary(sigs.intr)
```


## Adding gene names
Our result table only uses Ensembl gene IDs, but gene names may be more informative. Bioconductorâ€™s biomaRt package can help with mapping various ID schemes to each other.
```{r}

# First, create a data.frame of the result file 
sigs.main.df <- as.data.frame(sigs.main)
sigs.intr.df <- as.data.frame(sigs.intr)

```

```{r}

library(org.Hs.eg.db)

sigs.main.df$symbol <- mapIds(org.Hs.eg.db, keys=rownames(sigs.main.df), keytype= "ENSEMBL", column= "SYMBOL" )

sigs.intr.df$symbol <- mapIds(org.Hs.eg.db, keys=rownames(sigs.intr.df), keytype= "ENSEMBL", column= "SYMBOL" )

```

## Exporting results to CSV files
```{r}

# Save
write.csv(as.data.frame(sigs.main.df), file="DESeq2.Results.SigGenes.for.main.dds.new.limits.10-1M.csv" )


write.csv(as.data.frame(sigs.intr.df), file="DESeq2.Results.SigGenes.for.interaction.dds.new.limits.10-1M.csv" )

```


##Exploring and exporting results
### *MA-plot*
```{r}

plotMA(sigs.main, ylim=c(-2,2))

```


### *Volcano plot (check the distribution of log2FC vs pvalue)* 
```{r}

# Remove genes with extreme log2FC values (as outliers)
sigs.up <- filter(sigs.main.df, log2FoldChange >10 )
sigs.down <-  filter(sigs.main.df, log2FoldChange <= -10 )
rows.to.remove <- rbind(sigs.up, sigs.down)
sigs.sub <- sigs.main.df[!rownames(sigs.main.df)%in%rownames(rows.to.remove), ]

```

```{r}
# if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

# BiocManager::install("EnhancedVolcano")
```

```{r}

library("EnhancedVolcano")

EnhancedVolcano(sigs.sub ,
    lab = sigs.sub$symbol,
    x = 'log2FoldChange',
    y = 'pvalue',
    title = 'MT_PD versus Non_MT_PD',
    pCutoff = 10e-3,
    FCcutoff = 1,
    pointSize = 0.5,
    labSize = 3.0,
    col=c('grey90', 'grey90', 'deepskyblue3', 'red3'),
    colAlpha = 4/5)


```


## Viewing normalized counts for a single geneID
### *Step 1: sort the summary tibble by p-values and log2FCs *
```{r}

sigs.ordered <- sigs.sub[order(sigs.sub$log2FoldChange, sigs.sub$pvalue),]
head(sigs.ordered, 6)

```

### *Step 2: plotCounts*
```{r}

# We can use plotCounts fxn to compare the normalized counts
# between treated and control groups for our top 6 genes
par(mfrow=c(2,3))
plotCounts(dds.new, gene="ENSG00000258864", intgroup="MT.Grouping")
plotCounts(dds.new, gene="ENSG00000263917", intgroup="MT.Grouping")
plotCounts(dds.new, gene="ENSG00000239839", intgroup="MT.Grouping")
plotCounts(dds.new, gene="ENSG00000233913", intgroup="MT.Grouping")
plotCounts(dds.new, gene="ENSG00000273003", intgroup="MT.Grouping")
plotCounts(dds.new, gene="ENSG00000235288", intgroup="MT.Grouping")

```

### *Step 3: compare single gene counts between groups*
```{r}

library(ggplot2)

cohort= dds.new@colData$Cohort2

G1 <- plotCounts(dds.new, gene="ENSG00000258864", intgroup="MT.Grouping", returnData=TRUE)

G2 <- ggplot(G1, aes(x=MT.Grouping, y=count)) + 
  geom_boxplot(outlier.shape=NA) + 
  geom_jitter(shape=1, colour="red", position=position_jitter(0.2)) +
  ggtitle("ENSG00000258864 (MT vs NMT, PD_data)")+
  facet_grid(MT.Grouing ~ cohort)+
  theme_bw()+
  theme(axis.text = element_text(size = 10),
        axis.title=element_text(size=10,face="bold"))+
  theme(plot.title = element_text(size = 8, face = "bold"))+
  scale_y_log10()

G3 <- G2 + facet_grid(cohort)
G3
```

## Data transformations and visualization
### *Count data transformations*
```{r, message=FALSE, include=FALSE}

# BiocManager::install ("vsn") 
library("vsn")
ntd <- normTransform(dds.new)  # this gives log2(n + 1)

vsd <- vst(dds.new, blind=FALSE)

```

### *Effects of transformations on the variance*
The figures below plot the standard deviation of the transformed data, across samples, against the mean, using the shifted logarithm transformation, the regularized log transformation and the variance stabilizing transformation.
```{r}

par(mfrow=c(1,2))
meanSdPlot(assay(ntd))
meanSdPlot(assay(vsd))

```

## Principal component plot of the samples
```{r}

par(mfrow=c(2,2))
plotPCA(vsd, intgroup=c("Batch"))
plotPCA(vsd, intgroup=c("Sex"))
plotPCA(vsd, intgroup=c("Cohort2"))
plotPCA(vsd, intgroup=c("MT.Grouping"))

```

## Data quality assessment by sample clustering and visualization
### *Heatmap of the sample-to-sample distances*
Another use of the transformed data is sample clustering. Here, we apply the dist function to the transpose of the transformed count matrix to get sample-to-sample distances.
```{r}

# install.packages("pheatmap")
library("pheatmap")

sampleDists <- dist(t(assay(vsd)))

library("RColorBrewer")
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$condition, vsd$type, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)

pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

```

### *Heatmap of the count matrix*
```{r}

select <- order(rowMeans(counts(dds.new,normalized=TRUE)),
                decreasing=TRUE)[1:20]
df <- as.data.frame(colData(dds.new)[,c("Sex", "Cohort2", "MT.Grouping")])

pheatmap(assay(ntd)[select,], cluster_rows=FALSE, 
         show_rownames=FALSE, cluster_cols=FALSE,
         annotation_col=df)

```

### *Expression data heatmap*
```{r}

# Set a color palette
heat_colors <- colorRampPalette(brewer.pal(10, "RdYlBu"))(256)


# Define a vector of significant genes for mapping on the heatmap
top10up <- sigs.ordered[ 1:10, ] 
top10.down <- sigs.ordered[ 10883:10892, ] 
top20.genes <- rbind(top10up, top10.down)

heatmap(assay(ntd)[rownames(top20.genes), ], scale = "none",
        col =  heat_colors)         
```


## Additional approach to detect outliers (optional)
### *Step 1: Get the cooks distance matrix*
```{r}

Cooks <- assays(dds.new)[["cooks"]]

```

### *Step2: Diagnostic plots* 
```{r}

boxplot(log10(assays(dds.new)[["cooks"]]), range=0, las=2,
        cex.axis=0.6)

```

```{r}

mcols(dds.new)$maxCooks <- apply(assays(dds.new)[["cooks"]], 1, max)
plot(mcols(dds.new)$baseMean, mcols(dds.new)$maxCooks,
     cex.axis=0.7)

```

```{r}
# This requires you not filter or order the 'res' object
stopifnot(all.equal(rownames(dds.new), rownames(Res.main)))
plot(Res.main$log2FoldChange, mcols(dds.new)$maxCooks)

```


### *Step 3: Setting the cook's cutoff to filter the results*
The default cutoff is the .99 quantile of the F(p, m-p) distribution, where p is the number of coefficients being fitted and m is the number of samples."

The filtering only occurs in "cells" that contain 3 or more replicates, and by "cell" I mean unique combination of covariates in the design. So here ~ Age, PMI, Sex, Cohort2, and MT.Grouping are the relevant covariates. We don't filter if there are only two samples in the cell, for example, because we cannot reasonably identify which is an outlier in this case.

After looking at examples and upon deciding you want to filter on Cook's distance per gene, you can specify cooksCutoff. Going by the above formula: $F(p, m-p)$, F(7, 67)=> qf(.99, df1=7, df2=67) 
```{r}

# cutoff.thr <- qf(.99, df1=7, df2=67) # 2.91

```

```{r}

# Res.main$pvalue[mcols(dds.new)$maxCooks > 2.91] <- NA
#                                  #if I choose 2.91 as cooksCutoff
# 
# # optionally, also mean filtering:
# Res.main$pvalue[Res.main$baseMean <200000 ] <- NA
#                                             # 200,000 is the meanFilter
# Res.new$padj <- p.adjust(Res.new$pvalue, method="BH")


```

Note that applying the codes above will cause a significant change in the DE result. So, not sure if filtering counts data this way would be a good way to go!!!























